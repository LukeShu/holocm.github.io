<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Holo - Minimalistic Configuration Management</title>
    <link rel="stylesheet" type="text/css" href="./site.css">
    <link rel="stylesheet" type="text/css" href="./font/font-awesome.min.css">
    
</head>
<body>
    <header>
        <div id="header-container">
            <div id="header-icon" class="fixed-width">
                <a href="index.html"><img src="img/holo-logo.svg" alt="Holo"></a>
            </div>
            <div id="header-buttons" class="fixed-width">
                <a href="https://twitter.com/holocm" title="Follow on Twitter"><i class="fa fa-twitter"></i></a>
                <a href="https://github.com/holocm/holo" title="Fork on GitHub"><i class="fa fa-github"></i></a>
            </div>
        </div>
    </header>
    <div id="section-container">
        <section><div class="fixed-width clearfix"><h1 id="Name">Name</h1>

<p>holo-build - cross-distribution system package compiler</p>

</div></section><section><div class="fixed-width clearfix"><h1 id="Synopsis">Synopsis</h1>

<p>holo-build [<i>option</i>...] &lt; <i>file</i></p>

<p>holo-build <b>--help|--version</b></p>

</div></section><section><div class="fixed-width clearfix"><h1 id="Description">Description</h1>

<p>Holo adds a few sprinkles on top of package management to make it suitable for basic configuration management tasks. Its prime directive is to have all configuration statically declared and defined within packages, which can be installed to add new configuration, or uninstalled to remove configuration from a system.</p>

<p>However, the tools for creating system packages are optimized towards compiling applications for tarballs, and introduce needless complexity when you just want to package up a few files and list some dependencies. holo-build provides a simple, distribution-independent package description language and generates a system package from such a description.</p>

<p>For example, the following package description will build a package that installs and configures <code>systemd-timesyncd</code> with a custom NTP server:</p>

<pre><code>[package]
name     = &quot;hologram-systemd-timesyncd&quot;
version  = &quot;1.0&quot;
author   = &quot;Jane Doe &lt;jane.doe@example.org&gt;&quot;
requires = [&quot;systemd&quot;]
setupScript   = &quot;systemctl daemon-reload &amp;&amp; systemctl start systemd-timesyncd&quot;
cleanupScript = &quot;systemctl stop systemd-timesyncd&quot;

[[file]]
path     = &quot;/etc/systemd/timesyncd.conf.d/server.conf&quot;
content  = &quot;&quot;&quot;
    [Time]
    NTP=ntp.someserver.local
&quot;&quot;&quot;

[[symlink]]
# as created by `systemctl enable systemd-timesyncd`
path     = &quot;/etc/systemd/system/sysinit.target.wants/systemd-timesyncd.service&quot;
target   = &quot;/usr/lib/systemd/system/systemd-timesyncd.service&quot;</code></pre>

<p>The package description format is described below.</p>

</div></section><section><div class="fixed-width clearfix"><h1 id="Options">Options</h1>

<dl>

<dt id="stdout---no-stdout"><b>--stdout</b>/<b>--no-stdout</b></dt>
<dd>

<p>By default, the resulting package will be placed in the working directory using the naming convention for the corresponding output package format. If <b>--stdout</b> is given, the package will be printed directly to standard output instead.</p>

</dd>
<dt id="pacman"><b>--pacman</b></dt>
<dd>

<p>Generate a <code>pacman</code> package (suitable for Arch Linux and derivatives). This is the default under suitable distributions.</p>

</dd>
<dt id="debian"><b>--debian</b></dt>
<dd>

<p>Generate a Debian package (suitable for Debian and derivatives). This is the default under suitable distributions.</p>

</dd>
<dt id="suggest-filename"><b>--suggest-filename</b></dt>
<dd>

<p>Do not generate a package. After reading and validating the package definition, just print on standard output the suggested filename for this package. The printed file name is the same one that will be used when <code>--no-stdout</code> is in effect. The format for package filenames follows the recommendations of the targeted distribution:</p>

<pre><code>$ cat input.toml

[package]
name = &quot;foo&quot;
version = &quot;1.0&quot;

$ holo-build --suggest-filename --debian &lt; input.toml
the-package_1.0-1_any.deb
$ holo-build --suggest-filename --pacman &lt; input.toml
the-package-1.0-1-any.pkg.tar.xz</code></pre>

<p>This option can be used when auto-generating Makefiles, where the output filename needs to be known before <code>holo-build</code> runs (for purposes of dependency resolution).</p>

</dd>
<dt id="reproducible"><b>--reproducible</b></dt>
<dd>

<p>Try to generate a package that is more reproducible, that is: does not contain any timestamps and such. This switch does not actually guarantee a 100% reproducible package.</p>

<p>This switch should be considered internal, and only be used for testing purposes.</p>

</dd>
<dt id="help"><b>--help</b></dt>
<dd>

<p>Print out usage information.</p>

</dd>
<dt id="version"><b>--version</b></dt>
<dd>

<p>Print out Holo&#39;s version string including the release name.</p>

</dd>
</dl>

</div></section><section><div class="fixed-width clearfix"><h1 id="Package-description-format">Package description format</h1>

<p>Package descriptions are written in TOML format.</p>

<p class="follow"><a href="https://github.com/toml-lang/toml">TOML specification Â»</a></p>

<p>Only the <code>[package]</code> section is required. All other sections (and all fields not marked as required) are optional.</p>

<h2 id="package-section"><code>[package]</code> section</h2>

<p>This section is required and contains global properties for the package.</p>

<pre><code>[package]
name    = &quot;example-package&quot;
version = &quot;1.2.5-alpha.2&quot;
epoch   = 2
release = 3
description = &quot;An example package&quot;
author      = &quot;Jane Doe &lt;jane.doe@example.org&gt;&quot;
requires    = [ &quot;other-package &gt;= 2.0&quot; ]
provides    = [ &quot;example-package-api = 1.2&quot; ]
conflicts   = [ &quot;bloatware-package&quot; ]
replaces    = [ &quot;sample-package&quot; ]
setupScript   = &quot;touch /etc/example.conf &amp;&amp; systemctl reload cron&quot;
cleanupScript = &quot;rm -r /var/lib/example&quot;</code></pre>

<dl>

<dt id="name-string-required"><b>name</b> (string, required)</dt>
<dd>

<p>The package name. This string may never contain any slashes or newlines. The output format may impose additional charset or size restrictions on the package name. As a rule of thumb, the pattern <code>[a-z0-9-]+</code> is a safe set of allowed package names.</p>

<p>For <code>--debian</code>, the package name may contain <code>[a-z0-9+-.]</code>, but the first character must be alphanumeric.</p>

<p>For <code>--pacman</code>, the package name may contain <code>[a-z0-9@._+-]</code>, but the first character may not be a hyphen.</p>

</dd>
<dt id="version-string-required"><b>version</b> (string, required)</dt>
<dd>

<p>The package version. To ensure sanity, holo-build enforces a relatively strict pattern. Version numbers must be numbers (<code>0|[1-9][0-9]*</code>) chained together by dots:</p>

<pre><code>version = &quot;1.2.3&quot;
version = &quot;0.10&quot;
version = &quot;20151015&quot;
version = &quot;2015.10.15&quot;</code></pre>

</dd>
<dt id="epoch-unsigned-integer"><b>epoch</b> (unsigned integer)</dt>
<dd>

<p>An increase in the epoch (default: 0) can be used to force the package to be seen as newer than any previous version with a lower epoch. This is used when the version numbering scheme for a package changes, breaking normal version comparison logic.</p>

</dd>
<dt id="release-unsigned-integer"><b>release</b> (unsigned integer)</dt>
<dd>

<p>The release number (default: 1) can be appended if the same package is rebuilt multiple times without its contents changing, in order for the built packages to be distinguishable from one another.</p>

</dd>
<dt id="description-string"><b>description</b> (string)</dt>
<dd>

<p>A description of the purpose and contents of this package.</p>

</dd>
<dt id="author-string-required-for---debian"><b>author</b> (string, required for <code>--debian</code>)</dt>
<dd>

<p>The name and mail address of the package author, in the form <code>Name &lt;address&gt;</code>:</p>

<pre><code>[package]
author = &quot;Jane Doe &lt;jane.doe@example.org&gt;&quot;</code></pre>

</dd>
<dt id="requires-array-of-strings"><b>requires</b> (array of strings)</dt>
<dd>

<p>A list of other packages that must be installed when this package is installed. Some package managers call these <i>dependencies</i> instead. When a specific package version is required, a version test can be appended, using one of the operators <code>=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> or <code>&lt;=</code>. If multiple version tests are required, the same package can be stated multiple times.</p>

<pre><code>[package]
# require any version of foo, and a 2.x version of bar
requires = [ &quot;foo&quot;, &quot;bar &gt;= 2.0&quot;, &quot;bar &lt; 3.0&quot; ]</code></pre>

<p>When the package contains any files below <code>/usr/share/holo</code>, a requirement</p>

<pre><code>requires = [ &quot;holo&quot; ]</code></pre>

<p>is implied automatically.</p>

<p>For <code>--pacman</code> only, a special syntax is allowed to require complete package groups (by giving the groupname with a <code>group:</code> prefix), and to exclude certain packages or package groups from this group requirement (by prefixing the dependency with <code>not:</code>). For example, to have the package require all packages from the <code>xorg</code> group, except for the <code>xorg-drivers</code> group and the <code>xorg-docs</code> package:</p>

<pre><code>[package]
requires = [
    # require all packages from the xorg group
    &quot;group:xorg&quot;,
    # except for xorg-docs and all packages in the xorg-drivers group
    &quot;not:xorg-docs&quot;,
    &quot;not:group:xorg-drivers&quot;,
]</code></pre>

</dd>
<dt id="provides-array-of-strings"><b>provides</b> (array of strings)</dt>
<dd>

<p>A list of other packages (or virtual packages) that the software provides the features of. This means that this package can satisfy another package&#39;s requirement for the provided package. If a specific version is provided, this can be specified with the same syntax as for <code>requires</code>.</p>

<pre><code>[package]
name     = &quot;rewrite-of-foo&quot;
provides = [ &quot;foo = 2.1&quot; ] # this package acts like foo-2.1</code></pre>

<p>For <code>--debian</code>, the provided version syntax is not allowed. <code>provides</code> may only contain plain package names.</p>

</dd>
<dt id="conflicts-array-of-strings"><b>conflicts</b> (array of strings)</dt>
<dd>

<p>A list of other packages that may not be installed when this package is installed. Version tests can be added using the same syntax as for <code>requires</code>.</p>

</dd>
<dt id="replaces-array-of-strings"><b>replaces</b> (array of strings)</dt>
<dd>

<p>A list of obsolete packages that this package replaces. If this package is not installed, but one of the obsolete packages is installed, a system upgrade will result in the obsolete package being uninstalled, and this package being installed as a replacement.</p>

<p>If this package can replace the obsolete package, but it shall not be replaced automatically, don&#39;t use this; reference the obsolete package in both <code>provides</code> and <code>conflicts</code> instead.</p>

</dd>
<dt id="setupScript-string"><b>setupScript</b> (string)</dt>
<dd>

<p>A shell script that will be executed (as root) when the package is installed or updated, after the package files have been extracted to the file system.</p>

<p>If the package contains any files below <i>/usr/share/holo</i>, then <code>holo apply</code> will automatically run before this setup script is executed, so you can rely on provisioned files, user accounts and groups to be available already.</p>

</dd>
<dt id="cleanupScript-string"><b>cleanupScript</b> (string)</dt>
<dd>

<p>A shell script that will be executed (as root) when the package is being uninstalled, after the package files have been removed from the file system.</p>

<p>If the package contains any files below <i>/usr/share/holo</i>, then <code>holo apply</code> will automatically run before this cleanup script is executed.</p>

</dd>
<dt id="definitionFile-string"><b>definitionFile</b> (string)</dt>
<dd>

<p>A path where <code>[[user]]</code> and <code>[[group]]</code> sections will be placed inside the package. See the description of <code>[[user]]</code> and <code>[[group]]</code> sections below.</p>

</dd>
</dl>

<h2 id="file-section"><code>[[file]]</code> section</h2>

<p>Each one of these sections define a file to be added to the package.</p>

<pre><code>[[file]]
path    = &quot;/etc/foo.conf&quot;
mode    = &quot;0600&quot;
owner   = &quot;foouser&quot;
group   = &quot;foogroup&quot;
# alternative 1
content = &quot;&quot;&quot;
    content for foo.conf
    content for foo.conf
&quot;&quot;&quot;
# alternative 2
contentFrom = &quot;input.txt&quot;</code></pre>

<dl>

<dt id="path-string-required"><b>path</b> (string, required)</dt>
<dd>

<p>The path to this file. The path must be absolute and may not have a trailing slash.</p>

</dd>
<dt id="content-contentFrom-string-exactly-one-required"><b>content</b>/<b>contentFrom</b> (string, exactly one required)</dt>
<dd>

<p>If the <code>content</code> field is given, it contains the content of this file. Alternatively, <code>contentFrom</code> may reference a file whose contents will be used. This file must be present at package-build time; relative paths will be interpreted relative to the current working directory of the <code>holo-build</code> process.</p>

<p>If <code>content</code> is given, it may not be empty. To create an empty file, you can use <code>/dev/null</code> as a source:</p>

<pre><code>[[file]]
path        = &quot;/etc/empty-file.conf&quot;
contentFrom = &quot;/dev/null&quot;</code></pre>

</dd>
<dt id="raw-boolean"><b>raw</b> (boolean)</dt>
<dd>

<p>To aid readability, the <code>content</code> field allows strings to have indentation which will automatically be pruned. The following two sections are equivalent:</p>

<pre><code>[[file]]
path    = &quot;/etc/example.conf&quot;
content = &quot;&quot;&quot;
foo
    bar
baz
&quot;&quot;&quot;

[[file]]
path    = &quot;/etc/example.conf&quot;
content = &quot;&quot;&quot;
    foo
        bar
    baz
&quot;&quot;&quot;</code></pre>

<p>To disable this behavior and use leading whitespace verbatim, set the <code>raw</code> flag:</p>

<pre><code>[[file]]
path    = &quot;/etc/example.conf&quot;
raw     = true
content = &quot;&quot;&quot;
    foo
        bar
    baz
&quot;&quot;&quot;</code></pre>

</dd>
<dt id="mode-string"><b>mode</b> (string)</dt>
<dd>

<p>The mode bits for this file. Since TOML does not support octal number literals, this field must be given as a string containing an octal number:</p>

<pre><code>mode = &quot;0600&quot; # rw-------
mode = &quot;0755&quot; # rwxr-xr-x</code></pre>

</dd>
<dt id="owner-group-string-or-int"><b>owner</b>/<b>group</b> (string or int)</dt>
<dd>

<p>The owner (or group) for this file. If this field contains an integer, it is interpreted as the ID of the user or group. If this field contains a string, it is interpreted as a user/group name.</p>

<p>Since user/group names cannot be mapped to IDs at package build time, specifying a name will result in the file being packaged as belonging to user/group <code>root</code>, and the actual user/group will be applied at install time using <a href="http://man.he.net/man1/chown">chown(1)</a> or <a href="http://man.he.net/man1/chgrp">chgrp(1)</a>.</p>

</dd>
</dl>

<h2 id="directory-section"><code>[[directory]]</code> section</h2>

<p>Each one of these sections define a directory to be added to the package.</p>

<pre><code>[[directory]]
path = &quot;/var/lib/foo&quot;
mode = &quot;0600&quot;
owner = &quot;foouser&quot;
group = &quot;foogroup&quot;</code></pre>

<p>Note that directories are usually created automatically when files are placed in them. A <code>[[directory]]</code> section is only required to include an empty directory in the package, or to assign non-standard permissions or specific ownership to a directory.</p>

<dl>

<dt id="path-string-required1"><b>path</b> (string, required)</dt>
<dd>

<p>The path to this directory. The path must be absolute and may not have a trailing slash.</p>

</dd>
<dt id="mode-owner-group"><b>mode</b>/<b>owner</b>/<b>group</b></dt>
<dd>

<p>These are the same as for <code>[[file]]</code> sections; see above.</p>

</dd>
</dl>

<h2 id="symlink-section"><code>[[symlink]]</code> section</h2>

<p>Each one of these sections define a symlink to be added to the package.</p>

<pre><code>[[symlink]]
path   = &quot;/etc/foo.conf&quot;
target = &quot;bar.conf&quot;</code></pre>

<dl>

<dt id="path-string-required2"><b>path</b> (string, required)</dt>
<dd>

<p>The path to this directory. The path must be absolute and may not have a trailing slash.</p>

</dd>
<dt id="target"><b>target</b></dt>
<dd>

<p>The symlink target. Both relative and absolute targets are acceptable.</p>

</dd>
</dl>

<h2 id="user-and-group-sections"><code>[[user]]</code> and <code>[[group]]</code> sections</h2>

<p>These can be used to provision user accounts and groups when the package is installed. For example:</p>

<pre><code>[package]
name           = &quot;foobar&quot;
version        = &quot;1.0&quot;
definitionFile = &quot;/usr/share/holo/01-example.toml&quot;

[[group]]
name   = &quot;foobargroup&quot;
system = true

[[user]]
name   = &quot;foobaruser&quot;
uid    = 285
group  = &quot;foobargroup&quot;</code></pre>

<p>The user and group definitions are validated at package compilation time, and written into the file named in the <code>[package]</code> section. Since this file must be in <i>/usr/share/holo</i>, a dependency on <code>holo</code> is implied and <code>holo apply</code> is executed in the setup and cleanup scripts. So the previous example is functionally equivalent to:</p>

<pre><code>[package]
name          = &quot;foobar&quot;
version       = &quot;1.0&quot;
depends       = [&quot;holo&quot;]
setupScript   = &quot;holo apply&quot;
cleanupScript = &quot;holo apply&quot;

[[file]]
path    = &quot;/usr/share/holo/01-example.toml&quot;
content = &quot;&quot;&quot;
    [[group]]
    name   = &quot;foobargroup&quot;
    system = true

    [[user]]
    name   = &quot;foobaruser&quot;
    uid    = 285
    group  = &quot;foobargroup&quot;
&quot;&quot;&quot;</code></pre>

<p>The actual syntax and semantics of <code>[[user]]</code> and <code>[[group]]</code> sections is described in <a href="http://man.he.net/man8/holo">holo(8)</a>.</p></div></section>
    </div>
    <footer>
        <div class="fixed-width clearfix">
            This website is made with <a href="http://montserrat.zkysky.com.ar/en">Montserrat</a>
            and <a href="http://fontawesome.io">FontAwesome</a>
            and <a href="https://github.com/holocm/holocm.github.io">maintained at GitHub</a>.
        </div>
    </footer>
</body>
</html>
