<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Holo - Minimalistic Configuration Management</title>
    <link rel="stylesheet" type="text/css" href="./site.css">
    <link rel="stylesheet" type="text/css" href="./font/font-awesome.min.css">
    
</head>
<body>
    <header>
        <div id="header-container">
            <div id="header-icon" class="fixed-width">
                <a href="index.html"><img src="img/holo-logo.svg" alt="Holo"></a>
            </div>
            <div id="header-buttons" class="fixed-width">
                <a href="https://twitter.com/holocm" title="Follow on Twitter"><i class="fa fa-twitter"></i></a>
                <a href="https://github.com/holocm/holo" title="Fork on GitHub"><i class="fa fa-github"></i></a>
            </div>
        </div>
    </header>
    <div id="section-container">
        <section><div class="fixed-width clearfix"><h1 id="User-documentation">User documentation</h1>

<p>New to Holo? Check out our feature overview before diving into the details in here.</p>

<p class="follow"><a href="./tour.html">Take the tour Â»</a></p>

</div></section><section><div class="fixed-width clearfix"><h1 id="Installation">Installation</h1>

<p>The recommended method, if possible, is to install Holo as a package.</p>

<ul>

<li><p>Arch Linux users can use the <a href="https://aur.archlinux.org/packages/holo">AUR package</a>.</p>

</li>
<li><p>If you have packaged Holo for your distribution, please <a href="https://github.com/holocm/holo/issues/new">send me a link</a> that I can add to this list.</p>

</li>
</ul>

<p>Alternatively, to install from source, clone the <a href="https://github.com/holocm/holo">Git repository</a> and build the master branch:</p>

<pre><code>$ git clone https://github.com/holocm/holo
$ cd holo
$ make
$ make check
$ sudo make install</code></pre>

<p>You need <a href="https://golang.org">Go</a> to compile Holo and <a href="https://www.perl.org">Perl</a> to run the testcase. Packages for Go and Perl are available for all major distributions. Note that these are all build-time dependencies; when installed, Holo is a single static binary (plus manpage) that depends only on a UNIX kernel.</p>

</div></section><section><div class="fixed-width clearfix"><h1 id="Building-holograms">Building holograms</h1>

<p>In Holo, configuration is deployed in packages using the standard package management tools of your Linux distribution, so first, you should familiarize yourself with building and installing such packages. When administrating multiple systems, it is good practice to create a package repository to distribute configuration updates. To differentiate configuration packages from the application packages provided by your distribution, we&#39;re going to call these <i>holograms</i>.</p>

<p>The package management allows us to specify application packages and other holograms as dependencies of our hologram, and put configuration files into the hologram. Holo only comes into play when we go beyond the capabilities of the package management.</p>

</div></section><section><div class="fixed-width clearfix"><h1 id="The-configuration-repository">The configuration repository</h1>

<p>Package management does not allow multiple packages to install a file in the same location. So when an application package installs a default configuration file, a hologram cannot directly overwrite this configuration file.</p>

<pre><code>$ pacman -Qo /etc/nginx/nginx.conf
/etc/nginx/nginx.conf is owned by nginx 1.8.0-1</code></pre>

<p>Instead, Holo offers a configuration repository at <i>/usr/share/holo/repo</i> where the hologram can put its configuration file.</p>

<pre><code>$ pacman -Qo /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf
/usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf is owned by hologram-webserver 1.0.0-1</code></pre>

<p>The <code>holo apply</code> command is then used to install the hologram&#39;s configuration file in the right place. Most package management tools allow packages to carry post-install hooks for this purpose.</p>

<pre><code>$ sudo holo apply
[holo] Working on /etc/nginx/nginx.conf
[holo]   store at /var/lib/holo/backup/etc/nginx/nginx.conf
[holo]      apply /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf</code></pre>

<p>Entries in the configuration repository follow a fixed naming scheme:</p>

<pre><code>/usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf
  ^         ^            ^
  |         |            |
  |         |            +-- path to target
  |         |
  |         +-- disambiguator
  |
  +-- repository path</code></pre>

<p>The disambiguator is always required, and allows multiple repository files to operate on the same target (sorted alphabetically by their disambiguator). The pattern of putting a number at the start of the disambiguator is not required, but useful to control the ordering of repo files.</p>

</div></section><section><div class="fixed-width clearfix"><h1 id="Application-strategies">Application strategies</h1>

<p>When the repository file is a plain file or a symlink, the default strategy (&quot;apply&quot;) is to copy this file to the target location. Symlink targets are copied verbatim, so relative symlinks should be relative to the target directory.</p>

<p>When the repository file is an executable file or a symlink to an executable file carrying the extra <code>.holoscript</code> extension, the script is executed and the contents of the original file are piped through it to obtain the resulting configuration file. This strategy is called &quot;passthru&quot; in the output of <code>holo apply</code> and <code>holo scan</code>.</p>

<p>For example, the following setup installs the default configuration for Pacman, but enables the &quot;Color&quot; option which is commented out in the default configuration.</p>

<pre><code>$ holo scan
...
/etc/pacman.conf
    store at /var/lib/holo/backup/etc/pacman.conf
    passthru /usr/share/holo/repo/20-enable-color/etc/pacman.conf.holoscript
...
$ cat /usr/share/holo/repo/20-enable-color/etc/pacman.conf.holoscript
#!/bin/sh
sed &#39;s/^#\s*Color$/Color/&#39;</code></pre>

<p>The advantage of holoscripts over plain configuration files is that when the default configuration is updated, you get the updates as well during the next <code>holo apply</code>.</p>

<pre><code>$ sudo pacman -Syu
...
(3/8) upgrading pacman
warning: /etc/pacman.conf installed as /etc/pacman.conf.pacnew
... </code></pre>

<p>In this example, the system update includes a new default configuration, which is placed next to the currently used configuration. Holo will recognize this and use the new default configuration:</p>

<pre><code>$ sudo holo apply
...
[holo] Working on /etc/pacman.conf
[holo]     update /etc/pacman.conf.pacnew -&gt; /var/lib/holo/backup/etc/pacman.conf
[holo]   passthru /usr/share/holo/repo/20-enable-color/etc/pacman.conf.holoscript
... </code></pre>

<p>Another advantage is that multiple holoscripts can be chained. Multiple holograms can thus modify the same default configuration, or further specialize a base configuration provided by a base hologram:</p>

<pre><code>$ holo scan
...
/etc/pacman.conf
    store at /var/lib/holo/backup/etc/pacman.conf
       apply /usr/share/holo/repo/00-base/etc/pacman.conf
    passthru /usr/share/holo/repo/10-add-catalyst-repo/etc/pacman.conf.holoscript
    passthru /usr/share/holo/repo/20-enable-color/etc/pacman.conf.holoscript
... </code></pre>

<p>As seen in this example, the disambiguator is used to determine the application order when multiple repository files work on the same target. There is no restriction on how repository files are ordered. When somewhere in the application chain, a plain file is found, the effects of all previous application steps are discarded and overwritten by that config file.</p>

</div></section><section><div class="fixed-width clearfix"><h1 id="The-backup-directory">The backup directory</h1>

<p>Before Holo overwrites the default configuration supplied by the application package, it always takes a copy which is placed below <i>/var/lib/holo/backup</i>. This typically happens only once. The first <code>holo apply</code> after installing a new hologram might look like this:</p>

<pre><code>$ sudo holo apply
[holo] Working on /etc/nginx/nginx.conf
[holo]   store at /var/lib/holo/backup/etc/nginx/nginx.conf
[holo]      apply /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf</code></pre>

<p>But when <code>holo apply</code> is run again, it recognizes that the backup is already up-to-date:</p>

<pre><code>$ sudo holo apply
[holo] Working on /etc/nginx/nginx.conf
[holo]      apply /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf</code></pre>

<p>Besides allowing the user to inspect the default configuration, this backup serves two purposes: First, it is used as a base for applying holoscripts. Second, the owner, group, permissions and timestamps of the target configuration are always copied from this backup, and thus match the corresponding metadata of the default configuration.</p>

</div></section><section><div class="fixed-width clearfix"><h1 id="Management-of-UNIX-user-accounts-and-groups">Management of UNIX user accounts and groups</h1>

<p>Holograms can install TOML files into <i>/usr/share/holo</i> that describe UNIX user accounts and groups that shall be created during <code>holo apply</code> runs. (Previous releases used JSON files, which are still recognized, but deprecated.) For example:</p>

<pre><code>$ cat /usr/share/holo/01-example.toml

[[group]]
name   = &quot;foo&quot;

[[group]]
name   = &quot;bar&quot;
system = true

[[user]]
name   = &quot;foo&quot;
group  = &quot;foo&quot;

[[user]]
name   = &quot;qux&quot;
home   = &quot;/var/lib/qux&quot;
system = true

$ sudo holo apply
[holo] Working on group:bar
[holo]     create group with type: system
[holo] Working on group:foo
[holo]     create group
[holo] Working on user:foo
[holo]     create user with group: foo
[holo] Working on user:qux
[holo]     create user with type: system, home directory: /var/lib/qux</code></pre>

<p>Behind the scenes, this uses the <code>shadow</code> tools (<code>useradd</code>, <code>usermod</code>, <code>groupadd</code> and <code>groupmod</code>), so the above is exactly equivalent to</p>

<pre><code>$ sudo groupadd --system bar
$ sudo groupadd foo
$ sudo useradd --gid foo foo
$ sudo useradd --system --home-dir /var/lib/qux qux</code></pre>

<p>In the TOML definition files, the following attributes are accepted for groups:</p>

<dl>

<dt id="name"><code>name</code></dt>
<dd>

<p>(string) the group name</p>

</dd>
<dt id="system"><code>system</code></dt>
<dd>

<p>(bool) if true, gives <code>--system</code> to <code>groupadd</code></p>

</dd>
<dt id="gid"><code>gid</code></dt>
<dd>

<p>(integer) given to <code>groupadd</code> as <code>--gid</code></p>

</dd>
</dl>

<p>And the following attributes are accepted for users:</p>

<dl>

<dt id="name1"><code>name</code></dt>
<dd>

<p>(string) the user name</p>

</dd>
<dt id="comment"><code>comment</code></dt>
<dd>

<p>(string) given to <code>useradd</code> as <code>--comment</code></p>

</dd>
<dt id="system1"><code>system</code></dt>
<dd>

<p>(bool) if true, gives <code>--system</code> to <code>useradd</code></p>

</dd>
<dt id="uid"><code>uid</code></dt>
<dd>

<p>(integer) given to <code>useradd</code> as <code>--uid</code></p>

</dd>
<dt id="group"><code>group</code></dt>
<dd>

<p>(string) given to <code>useradd</code> as <code>--gid</code></p>

</dd>
<dt id="groups"><code>groups</code></dt>
<dd>

<p>(array of strings) given to <code>useradd</code> as <code>--groups</code></p>

</dd>
<dt id="home"><code>home</code></dt>
<dd>

<p>(string) given to <code>useradd</code> as <code>--home-dir</code></p>

</dd>
<dt id="shell"><code>shell</code></dt>
<dd>

<p>(string) given to <code>useradd</code> as <code>--shell</code></p>

</dd>
</dl>

<p>In either case, `name` is the only required attribute.</p>

<p>In contrast to files, where Holo operates very confidently (and only refuses operation when target files were modified manually), users and groups are treated more carefully. First, whenever an existing user account or group does not exactly match the definition in the TOML file, Holo will not touch it unless instructed to apply `--force`:</p>

<pre><code>$ sudo holo apply user:qux
[holo] Working on user:qux
[holo]        has home directory: /var/qux, expected /var/lib/qux (use --force to overwrite)
$ sudo holo apply --force user:qux
[holo] Working on user:qux
[holo]        fix home directory: /var/qux, expected /var/lib/qux</code></pre>

<p>Second, when a hologram is deleted, Holo will never automatically clean up users or groups (as it does for configuration files), since there might still be files belonging to the users/groups in question. Recommended best practice is to have the hologram print a message in its post-remove routine instructing the administrator to clean up lingering users/groups manually.</p>

<p>Like for configuration files, multiple holograms can contribute to a single entity. But when multiple definitions for one entity are stacked on top of each other, they are not allowed to contradict itself. For example, if two holograms define different home directories, this will be considered an error, since both holograms might rely on their respective home directory settings.</p>

<pre><code>$ cat /usr/share/holo/01-first.toml

[[user]]
name = &quot;foo&quot;
home = &quot;/home/foo&quot;

$ cat /usr/share/holo/02-second.toml

[[user]]
name = &quot;foo&quot;
home = &quot;/var/lib/foo&quot;

$ holo scan
[holo] Failed to read /usr/share/holo/02-second.toml:
[holo]     conflicting home directory for user &#39;foo&#39; (existing: /home/foo, new: /var/lib/foo)</code></pre></div></section>
    </div>
    <footer>
        <div class="fixed-width clearfix">
            This website is made with <a href="http://montserrat.zkysky.com.ar/en">Montserrat</a>
            and <a href="http://fontawesome.io">FontAwesome</a>
            and <a href="https://github.com/holocm/holocm.github.io">maintained at GitHub</a>.
        </div>
    </footer>
</body>
</html>
